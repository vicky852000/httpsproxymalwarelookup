readme

Requirements to Run this:

Environment:
1. Operating System OSX (I used MacBook Pro)
2. Install python 3.4.4 or +
   https://www.python.org/ftp/python/3.4.4/python-3.4.4-macosx10.6.pkg
3. Install pip if not present 
    sudo easy_install pip
4. Install virtual environment
   pip install virtualenv

5. virtualenv <app_name>
   Ex: virtualenv my_app

6. cd my_app/bin
7. source activate
8. pip install flask
9. clone my git repository 
   git https://github.com/vicky852000/httpsproxymalwarelookup.git
   make sure you already have git installed or else
   https://git-scm.com/download/mac
10.Editor Pycharm

IDEA:
This module comprise of three layers
  1. Presentation or Invoker Layer
  2. Service Layer
  3. DB Layer

Apart from these three layers user can access the service using
    1. console
    2. Using unit-test (which is mainly for dev)

1. Presentation or Invoker:
    Here the User can invoke the service using "serviceCaller.py". This utility loads the Urls from a file url.txt and invokes the service for these Urls.
    This layer has a method which can decide how many urls to load in memory if the list is growing more than memory size.

    Here I have assumed that I am getting only 1 MB RAM on system, so this utility load only 6 urls and next 6 in the next iteration (as each urls is of size 128bytes apppx. and I am loading 200bytes less to avoid crash. It can be optimised further).

    One can change this setting by changing
    serviceCaller::getMemorySize::available_memory = 1 # to the value you like or install psutil library.

    Once the execution is done if the list contains any Malware/Invalid Urls it will be printed on the console as well as the complete structure will
    be reported in the log

    logfile: service_caller.log

Data on Console
    [anksinh2 HttpsProxyMalwareLookup] => python serviceCaller.py
        Malware Url --> http://127.0.0.1:5000/urlinfo/101/10.10.1.36:10536/one/three?id=46&name=saurabh
        Malware Url --> http://127.0.0.1:5000/urlinfo/102/10.10.1.37:10537/two/three?id=14&name=munni
        Malware Url --> http://127.0.0.1:5000/urlinfo/103/10.10.1.38:10538/one/four?id=56&name=punit
        Invalid Url --> http://127.0.0.1:5000/ankur/sinha/
        Invalid Url --> http://127.0.0.1:5000/urlinfo/144/10.10.1.35:65536/one/two
        Invalid Url --> http://127.0.0.1:5000/urlinfo/144/:10535/one/two?id=44&name=ank45
        Invalid Url --> http://127.0.0.1:5000/urlinfo/144/10.10.1.35:/one/two?id=44&name=ank45
        Invalid Url --> http://127.0.0.1:5000/urlinfo/144/:/one/two?id=44&name=ank45
        Invalid Url --> http://127.0.0.1:5000/urlinfo/abc/10.10.1.35:10535/one/two?id=44&name=ank45
        Invalid Url --> http://127.0.0.1:5000/urlinfo//10.10.1.35:10535/one/two?id=44&name=ank45

Data in service_caller.log
        Malware Urls Sent
            [
             'http://127.0.0.1:5000/urlinfo/101/10.10.1.36:10536/one/three?id=46&name=saurabh',
             'http://127.0.0.1:5000/urlinfo/102/10.10.1.37:10537/two/three?id=14&name=munni',
             'http://127.0.0.1:5000/urlinfo/103/10.10.1.38:10538/one/four?id=56&name=punit'
             ]

        Stucture Received from service layer
        {'urls':
            [
              {
                'url_id': 105,
                'url_link': 'http://127.0.0.1:5000/urlinfo/105/10.10.1.35:10535/one/two?id=44&name=ank6',
                'error': False,
                'is_malware': 'False'
              },
              {
                'url_id': 101,
                'url_link': 'http://127.0.0.1:5000/urlinfo/101/10.10.1.36:10536/one/three?id=46&name=saurabh',
                'error': False,
                'is_malware': 'True'
              },
              {
                'desc': 'Invalid url ankur/sinha/...',
                'url_link': 'http://127.0.0.1:5000/ankur/sinha/',
                'error': True
              }
            ]
        }

2. Service Layer:
   This layer acts as a server, which exposes some api's using which user can check whether the url contains Malware urls
   It accepts the input in the structure of
        /urlinfo/<INETGER ID>/<HOSTNAME>:<PORT>/<PATH>?<QUERY STRING>
     ex:
        /urlinfo/101/10.10.1.36:10536/one/three?id=46&name=saurabh'
   if any other pattern is provided then, it will complain as invalid url error.

   Idea behind this is, we fetch the hostname,port,id,path and query string from the url and matches against the records which we already
   have stored in the malware database.

   This layer caches the data received from db layer for the next iteration. we can use LRU algorithm to optimise it further.


   ===> logfile: service_layer.log
   NOTE ===> To run the service you should be inside virtual environment where you have installed flask.

   To start Service you should type command "python servicelayer.py" on console. Once the service is started you can see the below
   messages on the console.

   ==========================================================================
   This is start the service(server) and you see below lines on your console

	   (httplookup) [anksinh2 httpsproxymalwarelookup] => python servicelayer.py
	 * Serving Flask app "servicelayer" (lazy loading)
	 * Environment: production
	   WARNING: Do not use the development server in a production environment.
	   Use a production WSGI server instead.
	 * Debug mode: off
	 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
   ==========================================================================

   Now the service is ready to take the Urls.

3. DB Layer:
   DB layer is a singleton class which creates only one instance and exposes some api's to fetch the malware data and to store.

   Using singleton class we can reduce the number of db calls which we have to make in case of infinite list of urls.

   Currently I have only 5 urls as malware, it can be increased further.

   sqlite> select * from malware;
    URL_ID      HOST        PORT        PATH        QSTRING
    ----------  ----------  ----------  ----------  ----------------
    100         10.10.1.35  10535       one/two     id=44&name=ankur
    101         10.10.1.36  10536       one/three   id=46&name=saura
    102         10.10.1.37  10537       two/three   id=14&name=munni
    103         10.10.1.38  10538       one/four    id=56&name=punit
    104         10.10.1.39  10539       three/four  id=45&name=seena

   ===> logfile: service_db.log
   ===> DB: malware.db

4. On Console:
   User can also send request for individual urls using below command

    [anksinh2 HttpsProxyMalwareLookup] => curl -i http://127.0.0.1:5000/urlinfo/101/10.10.1.36:10536/one/three?id=46\&name=saurabh
    HTTP/1.0 200 OK
    Content-Type: application/json
    Content-Length: 35
    Server: Werkzeug/0.14.1 Python/3.5.1
    Date: Thu, 21 Jun 2018 14:57:46 GMT

    {"is_malware":"True","url_id":101}
    [anksinh2 HttpsProxyMalwareLookup] =>

    ===> Notice '\' before '&' in url or it won't send the complete url to the service.

5. Unit Test:
   Unit tests are mainly written to maintain the uniform behaviour across multiple commits. It will break if some logics are changed but not handled
   correctly. Its only to help dev.

   One can run UT on console like below, UT loads the urls from test_url.txt file and also inline urls as mentioned in it.

   [anksinh2 HttpsProxyMalwareLookup] => python serviceCallerUT.py
    .....Malware Url --> http://127.0.0.1:5000/urlinfo/100/10.10.1.35:10535/one/two?id=44&name=ankur
    Malware Url --> http://127.0.0.1:5000/urlinfo/101/10.10.1.36:10536/one/three?id=46&name=saurabh
    Malware Url --> http://127.0.0.1:5000/urlinfo/102/10.10.1.37:10537/two/three?id=14&name=munni
    Malware Url --> http://127.0.0.1:5000/urlinfo/103/10.10.1.38:10538/one/four?id=56&name=punit
    Invalid Url --> http://127.0.0.1:5000/ankur/
    .......
    ----------------------------------------------------------------------
    Ran 12 tests in 0.048s

    OK
    ===> logfile: unit_test.log
    ===> Make sure Service is running when you run these UT's


Steps:
========================================================================================================================
      As mentioned above, I am assuming you are already in virtualenv and activated app and installed flask as directed.
========================================================================================================================

1. open two terminals and goto the project httpsproxymalwarelookup on both the terminals and make sure
   you are able to see the python files there.

2. on one console excute the command.
   python servicelayer.py

   This is start the service(server) and you see below lines on your console

	   (httplookup) [anksinh2 httpsproxymalwarelookup] => python servicelayer.py
	 * Serving Flask app "servicelayer" (lazy loading)
	 * Environment: production
	   WARNING: Do not use the development server in a production environment.
	   Use a production WSGI server instead.
	 * Debug mode: off
	 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 

3. Now from the other console you can either try out individual request like.
   curl -i http://127.0.0.1:5000/all/malwares/

   this will give you all the available malware in the database.

   output:
   [anksinh2 httpsproxymalwarelookup] => curl -i http://127.0.0.1:5000/all/malwares/
		HTTP/1.0 200 OK
		Content-Type: application/json
		Content-Length: 294
		Server: Werkzeug/0.14.1 Python/3.5.1
		Date: Thu, 21 Jun 2018 13:22:26 GMT

		{"records":[[100,"10.10.1.35",10535,"one/two","id=44&name=ankur"],[101,"10.10.1.36",10536,"one/three","id=46&name=saurabh"],[102,"10.10.1.37",10537,"two/three","id=14&name=munni"],[103,"10.10.1.38",10538,"one/four","id=56&name=punit"],[104,"10.10.1.39",10539,"three/four","id=45&name=seena"]]}
		
4. To run service caller script you can use the following command
    python serviceCaller.py

5. To run unit test type below command
   python serviceCallerUT.py

Make sure service is up and running when you execute #3,#4 and #5.
